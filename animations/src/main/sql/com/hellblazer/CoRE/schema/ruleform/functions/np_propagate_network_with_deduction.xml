<?xml version="1.0" encoding="UTF-8"?>

<databaseChangeLog xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
    http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-2.0.xsd">
    
    <changeSet id="1" author="hhildebrand">
        <sql splitStatements="false"><![CDATA[
            CREATE OR REPLACE FUNCTION ruleform.np_propagate_network_with_deduction(network_table character varying)
              RETURNS integer AS
            $BODY$
            DECLARE
                debug_flag BOOLEAN := FALSE;
            
                propagation_resource VARCHAR := 'Propagation Software'; -- pinned
                inverse_resource VARCHAR := 'Inverse Software'; -- pinned
            
                 /*
                    This tells us how many rules are generated on a single pass of the propagation algorithm
                    When no new rules are generated on a pass, processing is done.
                */
                number_of_new_rules INTEGER := 0;
                total_rules INTEGER := 0;
                query VARCHAR;
            
                start_of_step TIMESTAMP;
            
                /*
                    This is an optimization for when networks get large.
                */
                first_pass BOOLEAN := TRUE;
            BEGIN
                /*
                    We must verify that the name of the table passed in as a parameter is valid for use in this function.
                    If it isn't, throwing an exception terminates execution before anything bad can happen.
                */
                -- IF NOT valid_evidence_network(network_table) THEN
                --     RAISE EXCEPTION 'This function cannot propagate the table %', network_table;
                --    END IF;
            
                /*
                This table will hold a "working memory" of newly-deduced rules and the rules used to deduce them.
                */
                query :=
                 'CREATE TEMPORARY TABLE working_memory(
                    resource BIGINT NOT NULL,
                    parent BIGINT NOT NULL,
                    relationship BIGINT NOT NULL,
                    child BIGINT NOT NULL,
                    distance INTEGER NOT NULL,
                    updated_by BIGINT NOT NULL,
                    premise1 BIGINT NOT NULL,
                    premise2 BIGINT NOT NULL
                )';
                IF debug_flag THEN
                    RAISE NOTICE 'Query = %', query;
                ELSE
                    EXECUTE query;
                END IF;
                RAISE NOTICE 'Generated working_memory';
                
                query := 
                'CREATE TEMPORARY TABLE last_pass_rules (    
                    id BIGINT NOT NULL,
                    resource BIGINT NOT NULL,
                    parent BIGINT NOT NULL,
                    relationship BIGINT NOT NULL,
                    child BIGINT NOT NULL,
                    distance INTEGER NOT NULL,
                    updated_by BIGINT NOT NULL
                )';
                IF debug_flag THEN
                    RAISE NOTICE 'Query = %', query;
                ELSE
                    EXECUTE query;
                END IF;
                
                RAISE NOTICE 'Generated last_pass_rules';
            
                query :=
                'CREATE TEMPORARY TABLE current_pass_rules (         
                    id BIGINT NOT NULL,
                    resource BIGINT NOT NULL,
                    parent BIGINT NOT NULL,
                    relationship BIGINT NOT NULL,
                    child BIGINT NOT NULL,
                    distance INTEGER NOT NULL,
                    updated_by BIGINT NOT NULL
                 )';
                 IF debug_flag THEN
                     RAISE NOTICE 'Query = %', query;
                 ELSE
                     EXECUTE query;
                 END IF;
                
                RAISE NOTICE 'Generated current_pass_rules';
                
                query :=
                'CREATE TEMPORARY TABLE current_pass_existing_rules (
                     id BIGINT NOT NULL,
                     resource BIGINT NOT NULL,
                     parent BIGINT NOT NULL,
                     relationship BIGINT NOT NULL,
                     child BIGINT NOT NULL,
                     distance INTEGER NOT NULL,
                     updated_by BIGINT NOT NULL,
                     premise1 BIGINT NOT NULL,
                     premise2 BIGINT NOT NULL
                 )';
                
                 IF debug_flag THEN
                     RAISE NOTICE 'Query = %', query;
                 ELSE
                     EXECUTE query;
                 END IF;
                
                RAISE NOTICE 'Generated current_pass_existing_rules';
                
                LOOP
                    /*
                    This query deduces all possible new rules for a single propagation step.  Some of these rules
                    will already have been deduced by another path, while others are newly deduced.  We will separate
                    these two group later, as each requires unique processing
                    */
                   query := 
                   'INSERT INTO working_memory(resource, parent, relationship, child, distance, updated_by, premise1, premise2)   
                        SELECT 
                        CASE 
                            WHEN premise1.resource = premise2.resource 
                                THEN premise1.resource 
                            ELSE resource_id('|| quote_literal(propagation_resource) ||') 
                        END AS resource,
                        premise1.parent, 
                        chain.result, 
                        premise2.child,
                        (premise1.distance + premise2.distance) as distance,
                        resource_id('|| quote_literal(propagation_resource) ||'), 
                        premise1.id, 
                        premise2.id 
                        FROM  (SELECT n.id, n.resource, n.parent, n.relationship, n.child, n.distance FROM ';
                             IF first_pass THEN
                                query := query || network_table || ' AS n ';
                                first_pass := FALSE;
                            ELSE
                                query := query ||' last_pass_rules AS n ';
                            END IF;
                        query := query || ') as premise1
                        JOIN  (SELECT n.id, n.resource, n.parent, n.relationship, n.child, n.distance
                            FROM ' || network_table || ' AS n 
                            WHERE 
                                -- preferred?
                                n.distance = 1
                              AND n.updated_by != resource_id('|| quote_literal(inverse_resource) ||')
                        ) as premise2  
                        ON premise2.parent = premise1.child 
                            AND premise2.child <> premise1.parent
                        JOIN relationship_chain AS chain
                            ON premise1.relationship = chain.input1
                            AND premise2.relationship = chain.input2
                        ';
                        
                        IF debug_flag THEN
                            RAISE NOTICE 'Query = %', query;
                        ELSE
                            start_of_step := timeofday()::TIMESTAMP;
                            EXECUTE query;
                            RAISE NOTICE 'End select into working memory; elapsed time: %', (timeofday()::TIMESTAMP - start_of_step);
                        END IF;
                        
                        
                        /*
                            First we need to handle deductions that already exist in the network table.  If they were deduced by a new path in this pass of deduction, 
                            this needs to be recorded in the deduction table.
                        */
                        
                       /* This query retrieves the unique id for each of the rules that have been deduced previously. */   
                       query :=
                       'INSERT INTO current_pass_existing_rules
                       SELECT exist.id, wm.*
                       FROM working_memory AS wm
                       JOIN ' || network_table || ' AS exist
                       ON wm.resource = exist.resource 
                        AND wm.parent = exist.parent 
                        AND wm.relationship = exist.relationship 
                        AND wm.child = exist.child
                        ';
                        IF debug_flag THEN
                            RAISE NOTICE 'Query = %', query;
                        ELSE
                            start_of_step := timeofday()::TIMESTAMP;
                            EXECUTE query;
                            RAISE NOTICE 'End select into current pass existing rules; elapsed time: %', (timeofday()::TIMESTAMP - start_of_step);
                        END IF;
                        
                    /*
                        Now, for each of the existing rules that has a previously unencountered deduction path, record that deduction path.
                    */
                        query :=
                        'INSERT INTO ' || network_table || '_deduction(deduction, premise1, premise2, updated_by)
                        SELECT c.id, c.premise1, c.premise2, resource_id('|| quote_literal(propagation_resource) ||') 
                        FROM current_pass_existing_rules AS c
                        LEFT OUTER JOIN ' || network_table || '_deduction AS b
                                    ON c.id = b.deduction
                                    AND c.premise1 = b.premise1
                                    AND c.premise2 = b.premise2
                                WHERE b.deduction IS NULL
                                  AND b.premise1 IS NULL
                                  AND b.premise2 IS NULL
                                ';
                        IF debug_flag THEN
                            RAISE NOTICE 'Query = %', query;
                        ELSE
                            start_of_step := timeofday()::TIMESTAMP;
                            EXECUTE query;
                            RAISE NOTICE 'End insert into deduction table of existing rules; elapsed time: %', (timeofday()::TIMESTAMP - start_of_step);
                        END IF;
                        
                        
                        /*
                            Now we deal with completely new rules.  First they must be added to the network table, and then their deduction paths must be added to the deduction table.
                        */
                        /*
                            There are cases when the same rule can be deduced in multiple ways on the same pass.
                            This pulls out all the unique combinations of resource, parent, relationship and child
                            from working memory.  These define the rules that should be inserted as 'new' into the 
                            network table
                         */
                       query := 
                       'INSERT INTO current_pass_rules
                            SELECT nextval(' || quote_literal(network_table || '_id_seq') || '), wm.* FROM
                            (SELECT resource, parent, relationship, child, min(distance), min(updated_by) -- always Propagation Software
                              FROM working_memory
                              GROUP BY resource, parent, relationship, child) AS wm
                            LEFT OUTER JOIN ' || network_table || ' AS exist
                                ON wm.resource = exist.resource 
                                AND wm.parent = exist.parent 
                                AND wm.relationship = exist.relationship 
                                AND wm.child = exist.child
                            WHERE exist.resource IS NULL 
                              AND exist.parent IS NULL 
                              AND exist.relationship IS NULL 
                              AND exist.child IS NULL
                        ';
                        IF debug_flag THEN
                            RAISE NOTICE 'Query = %', query;
                        ELSE
                            start_of_step := timeofday()::TIMESTAMP;
                            EXECUTE query;
                            RAISE NOTICE 'End insert into current pass rules; elapsed time: %', (timeofday()::TIMESTAMP - start_of_step);
                        END IF;
                       
                        IF NOT debug_flag THEN
                            GET DIAGNOSTICS number_of_new_rules = ROW_COUNT;
                            RAISE NOTICE 'Generated % propagated rules', number_of_new_rules;
                            total_rules = total_rules + number_of_new_rules;
                            --If the number of rules generated in this pass is 0, then we're done.
                            EXIT WHEN number_of_new_rules = 0;
                        END IF;
                        /*
                            These two queries load data into the network table and deduction path table, respectively.
                        */      
                        query :=
                        'INSERT INTO ' || network_table || '(id, resource, parent, relationship, child, updated_by, distance)
                        SELECT id, resource, parent, relationship, child, updated_by, distance
                        FROM current_pass_rules';
                        IF debug_flag THEN
                            RAISE NOTICE 'Query = %', query;
                        ELSE
                            start_of_step := timeofday()::TIMESTAMP;
                            EXECUTE query;
                            RAISE NOTICE 'End insert into network table; elapsed time: %', (timeofday()::TIMESTAMP - start_of_step);
                        END IF;
                        
                        query :=
                        'INSERT INTO ' || network_table || '_deduction(deduction, premise1, premise2, updated_by)
                        SELECT cpr.id, wm.premise1, wm.premise2, resource_id('|| quote_literal(propagation_resource) ||') 
                        FROM current_pass_rules AS cpr 
                        JOIN working_memory AS wm 
                            ON cpr.resource = wm.resource 
                            AND cpr.parent = wm.parent 
                            AND cpr.relationship = wm.relationship 
                            AND cpr.child = wm.child';     
                       IF debug_flag THEN
                           RAISE NOTICE 'Query = %', query;
                       ELSE
                           start_of_step := timeofday()::TIMESTAMP;
                           EXECUTE query;
                           RAISE NOTICE 'End insert into deduction table of new rules; elapsed time: %', (timeofday()::TIMESTAMP - start_of_step);
                        END IF;
                        
                        /*
                            Everything is where it needs to be now... time to clean up the temporary tables and move on to the next iteration of the loop
                        */
                    IF NOT debug_flag THEN
                       EXECUTE 'TRUNCATE TABLE last_pass_rules';
                       EXECUTE 'ALTER TABLE current_pass_rules RENAME TO temp_last_pass_rules';
                       EXECUTE 'ALTER TABLE last_pass_rules RENAME TO current_pass_rules';
                       EXECUTE 'ALTER TABLE temp_last_pass_rules RENAME TO last_pass_rules';
                       EXECUTE 'TRUNCATE current_pass_existing_rules';
                       EXECUTE 'TRUNCATE working_memory';
                    END IF;
                    
                        IF debug_flag THEN
                            EXIT;
                        END IF;
                    END LOOP;
                
                       /*
                            Finally, generate contras for all rules in the table
                       */
                       IF NOT debug_flag THEN
                            start_of_step := timeofday()::TIMESTAMP;
                            SELECT np_generate_inverse_rules(network_table) INTO number_of_new_rules; 
                            total_rules := total_rules + number_of_new_rules;
                            RAISE NOTICE 'Generated inverse rules; elapsed time: %', (timeofday()::TIMESTAMP - start_of_step);
                            
                            EXECUTE 'DROP TABLE working_memory';
                            EXECUTE 'DROP TABLE last_pass_rules';
                            EXECUTE 'DROP TABLE current_pass_rules';
                            EXECUTE 'DROP TABLE current_pass_existing_rules';
                       END IF;
                      RETURN total_rules;
                END;
            $BODY$
              LANGUAGE plpgsql VOLATILE
              COST 100;
            ALTER FUNCTION ruleform.np_propagate_network_with_deduction(character varying)
              OWNER TO core;
            COMMENT ON FUNCTION ruleform.np_propagate_network_with_deduction(character varying) IS 'Propagates resource-qualified, evidence-tracked network ruleforms';
            ]]>
        </sql>
        <rollback> DROP FUNCTION ruleform.np_propagate_network_with_deduction(character varying); </rollback>
    </changeSet>
</databaseChangeLog>
