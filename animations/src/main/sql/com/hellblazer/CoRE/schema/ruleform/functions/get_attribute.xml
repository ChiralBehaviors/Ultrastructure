<?xml version="1.0" encoding="UTF-8"?>

<databaseChangeLog xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
    http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-2.0.xsd">
    
    <changeSet id="1" author="hhildebrand">
        <sql splitStatements="false"><![CDATA[
            CREATE OR REPLACE FUNCTION ruleform.get_attribute(the_resource bigint, the_product bigint, the_attribute bigint)
              RETURNS SETOF ruleform.product_attribute AS
            $BODY$
            DECLARE
                row ruleform.product_attribute%rowtype;
                is_inheritable BOOLEAN := FALSE;
                the_distance INTEGER := NULL;
            BEGIN
            
                -- see if the attribute exists already
                SELECT * INTO row 
                FROM product_attribute AS ba 
                WHERE ba.resource = the_resource 
                  AND ba.product = the_product 
                  AND ba.attribute = the_attribute;
                
                IF row.id IS NOT NULL THEN
                    /*
                        I'm doing this return-next-return thing because I want this function
                        to return a single row if an attribute rule exists, or NO rows if 
                        the attribute rule does not exist.  If the function is declared
                        to return 'product_attribute' rather than 'SETOF product_attribute',
                        then if no attribute rule exists, a product_attribute is returned
                        where every column is NULL, which is not what I want!
                    */
                    RETURN NEXT row;
                    RETURN;
                END IF;
                
                -- nothing was found, need to find inherited attributes
                
                -- first, see if the attribute is inheritable
                SELECT inheritable INTO is_inheritable
                FROM attribute
                WHERE id = the_attribute;
                
               IF is_inheritable IS FALSE THEN
                  RAISE NOTICE '% is not an inheritable attribute', attribute_name(the_attribute);
                  RETURN;
               END IF;
                
                -- figure out how deep into the network we are
                SELECT max(distance) INTO the_distance
                    FROM product_network
                    WHERE parent = the_product;
                RAISE NOTICE 'Distance is %', the_distance;
                
                IF the_distance IS NULL THEN
                    -- bail out, nothing can be done here!
                    RAISE EXCEPTION '% does not appear to be linked to anything in the product_network!', product_name(the_product);
                END IF;
            
                FOR index IN 1 .. the_distance LOOP
                RAISE NOTICE 'Loop index is %', index;
                    SELECT ba.* INTO row 
                    FROM 
                        product_network AS n 
                            JOIN relationship AS r ON n.relationship = r.id
                            JOIN product_attribute AS ba ON n.child = ba.product
                        WHERE n.parent = the_product
                          --AND r.preferred IS FALSE -- go up toward the top (is this really needed?)
                          AND ba.resource = the_resource -- the resource passed in ???
                          AND ba.attribute = the_attribute -- the attribute passed in (attribute_id('Direction') )
                          AND n.distance = index -- the current level in the network
                    ;
                    IF row.id IS NOT null THEN
                        RAISE NOTICE 'Found something';
                        -- same reason for this as before... look up in the code to see it.
                        RETURN NEXT row;
                        RETURN;
                   END IF;
                   -- if we got here, we didn't find anything, so we need to continue examining
                   -- the network further out
                   RAISE NOTICE 'Didn''t find an attribute for resource=''%'', product=''%'', and attribute=''%''', resource_name(the_resource), product_name(the_product), attribute_name(the_attribute);
                END LOOP;
                
                -- if you can't find anything, return the null row
                RAISE NOTICE 'Didn''t find anything';
                return NEXT row;
            RETURN;
            END;
            $BODY$
              LANGUAGE plpgsql STABLE
              COST 100
              ROWS 1000;
            ALTER FUNCTION ruleform.get_attribute(bigint, bigint, bigint)
              OWNER TO core;
            ]]>
        </sql>
        <rollback> DROP FUNCTION ruleform.get_attribute(bigint, bigint, bigint); </rollback>
    </changeSet>
</databaseChangeLog>
