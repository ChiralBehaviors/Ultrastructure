<?xml version="1.0" encoding="UTF-8"?>

<databaseChangeLog xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
    http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-2.0.xsd">

    <changeSet id="1" author="hhildebrand">
        <sql splitStatements="false"><![CDATA[
            CREATE OR REPLACE FUNCTION ruleform.np_generate_inverse_rules(network_table character varying)
              RETURNS integer AS
            $BODY$
            /*
                This function generates inverse rules for the given network table.  It returns
                the number of new rules generated.
            
                This function pins the resource 'Inverse Software', since it refers to it
                explicitly by name.
            */
            DECLARE
                
                inverse_resource VARCHAR := 'Inverse Software'; -- pinned
                
                -- this flag indicates whether or not the table is a valid one to operate on
                valid BOOLEAN := false;
                
                -- this flag indicates whether or not the table has a resource factor; the
                -- query ultimately formed depends on this
                has_resource BOOLEAN := false;
            
                -- this is how many new rules were created.  It is returned to the client
                rows_modified INTEGER;
                
                
                query VARCHAR;
                
                -- these are for debugging and logging output
                start_of_step TIMESTAMP;
                debug_flag BOOLEAN := FALSE;
            BEGIN
                /*
                   We must verify that the name of the table passed in as a parameter is 
                   valid for use in this function.  If it isn't, throwing an exception 
                   terminates execution before anything bad can happen.
               */
                SELECT EXISTS(
                    SELECT t.table_name
                    FROM information_schema.tables AS t
                    WHERE t.table_name LIKE '%_network' 
                      AND t.table_schema = 'ruleform' 
                      AND t.table_name  = quote_ident(network_table) -- quote_ident because the datatype is sql_identifier?
                ) INTO valid;
            
                IF NOT valid THEN
                   RAISE EXCEPTION 'This function cannot generate inverse rules for the table %', network_table;
                END IF;
            
                /*
                    TODO: might want to add a check that the resource column is part of the factors of the ruleform?
                */
                SELECT EXISTS(
                    SELECT c.column_name
                    FROM information_schema.columns AS c
                    WHERE c.table_name LIKE '%_network' 
                      AND c.table_schema = 'ruleform' 
                      AND c.table_name  = quote_ident(network_table) -- quote_ident because the datatype is sql_identifier?
                      AND c.column_name = 'resource'
                ) INTO has_resource;
            
                /*
                    This query is what does the work.  Each new inverse rule can be generated by simply
                    "flipping" an existing rule around, using the inverse relationship code and swapping
                    parent and child.  This is accomplished with the new_contra subquery.  The LEFT JOIN is for
                    filtering out any duplicates.
                */
                IF has_resource THEN
                    query := 
                    'INSERT INTO ' || quote_ident(network_table) || '(resource, parent, relationship, child, updated_by, distance)
                    SELECT 
                        net.resource as resource,
                        net.child as parent, 
                        rel.inverse as relationship, 
                        net.parent as child, 
                        resource_id(' || quote_literal(inverse_resource) || ') as updated_by, 
                        net.distance
                    FROM ' || quote_ident(network_table) || ' AS net
                    JOIN relationship AS rel ON net.relationship = rel.id
                    LEFT OUTER JOIN ' || quote_ident(network_table) || ' AS exist 
                        ON net.resource = exist.resource
                        AND net.child = exist.parent 
                        AND rel.inverse = exist.relationship 
                        AND net.parent = exist.child
                    WHERE exist.resource IS NULL
                      AND exist.parent IS NULL 
                      AND exist.relationship IS NULL 
                      AND exist.child IS NULL';
                ELSE
                query :=
                    'INSERT INTO ' || quote_ident(network_table) || '(parent, relationship, child, updated_by, distance)
                    SELECT net.child as parent, 
                        rel.inverse as relationship, 
                        net.parent as child, 
                        resource_id(' || quote_literal(inverse_resource) || ') as updated_by, 
                        net.distance
                    FROM ' || quote_ident(network_table) || ' AS net
                    JOIN relationship AS rel ON net.relationship = rel.id
                    LEFT OUTER JOIN ' || quote_ident(network_table) || ' AS exist 
                        ON net.child = exist.parent 
                        AND rel.inverse = exist.relationship 
                        AND net.parent = exist.child
                    WHERE exist.parent IS NULL 
                      AND exist.relationship IS NULL 
                      AND exist.child IS NULL';
                END IF;
            
                IF debug_flag THEN
                    RAISE NOTICE 'Query is %', query;
                ELSE
                    start_of_step := timeofday()::TIMESTAMP;
                    EXECUTE query;
                    --Figure out how many new rules got loaded up and return that value.
                    GET DIAGNOSTICS rows_modified := ROW_COUNT;
                    RAISE NOTICE 'End inverse rule generation; elapsed time: %', (timeofday()::TIMESTAMP - start_of_step);
                END IF;
                RETURN rows_modified;
            END;
            $BODY$
              LANGUAGE plpgsql VOLATILE
              COST 100;
            ALTER FUNCTION ruleform.np_generate_inverse_rules(character varying)
              OWNER TO core;
            COMMENT ON FUNCTION ruleform.np_generate_inverse_rules(character varying) IS 'Generates inverse rules for the given network table.  It returns the number of new rules generated.';

            ]]>
        </sql>
        <rollback> DROP FUNCTION ruleform.np_generate_inverse_rules(character varying); </rollback>
    </changeSet>
</databaseChangeLog>
