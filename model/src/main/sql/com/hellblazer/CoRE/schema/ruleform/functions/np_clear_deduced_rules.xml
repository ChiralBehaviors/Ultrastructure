<?xml version="1.0" encoding="UTF-8"?>

<databaseChangeLog xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
    http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-2.0.xsd">
    
    <changeSet id="1" author="hhildebrand">
        <sql splitStatements="false"><![CDATA[
            CREATE OR REPLACE FUNCTION ruleform.np_clear_deduced_rules(network_table character varying)
              RETURNS integer AS
            $BODY$ 
            /*
                This function removes all deduced rules from the given network table.  While
                this can be simply done by 'DELETE FROM <table> WHERE ...', this 
                function adds some error checking, and helpfully resets the sequence backing
                the 'id' column to reclaim the ids used by the deleted inferred rules.
                
                This function pins the 'Inverse Software' resource.
            */
            DECLARE
                -- If this is TRUE, then generated queries are logged, but not performed
                -- If it's FALSE, then the generated queries are not logged, but are performed
                debug_flag BOOLEAN := FALSE;
            
                inverse_resource VARCHAR := 'Inverse Software'; -- pinned
            
                valid BOOLEAN := false;
                query VARCHAR;
                rows_modified INTEGER;
                
                start_of_step TIMESTAMP;
                
            BEGIN
                /*
                    Performs a basic validity check based on system metadata.  If the table
                    given is in the public schema, ends with '_network' and has a integer
                    column named 'distance', we proceed.  Otherwise, an exception is thrown.
                */
                SELECT EXISTS(
                    SELECT t.table_name
                    FROM information_schema.tables AS t
                        JOIN information_schema.columns AS c
                            ON t.table_name = c.table_name 
                            AND t.table_schema = c.table_schema
                    WHERE t.table_name LIKE '%_network' 
                        AND t.table_schema = 'ruleform' 
                        AND t.table_name  = quote_ident(network_table)
                        AND c.column_name = 'distance'
                        AND c.data_type = 'integer'
                ) INTO valid;
            
                IF NOT valid THEN
                    RAISE EXCEPTION 'This function cannot clear deduced rules for the table %', network_table;
                END IF;
                
                /* 
                    All original rules are defined to have a distance of 1 (i.e. users should
                    only enter parent-child links directly, and allow the inference algorithm
                    to fill in the rest).  Inverse rules also have a distance of 1, but are 
                    declared by 'Inverse Software'.
                    
                    Thus, delete all rules with distance > 1, as well as all rules with 
                    updated_by = 'Inverse Software'
                */
                query := 'DELETE FROM ' 
                    || quote_ident(network_table) 
                    || ' WHERE distance > 1 OR updated_by = resource_id(' || quote_literal(inverse_resource) || ')';
                IF debug_flag THEN
                    RAISE NOTICE 'Query = %', query;
                ELSE
                    start_of_step := timeofday()::TIMESTAMP;
                    EXECUTE query;
                    RAISE NOTICE 'End deletion; elapsed time: %', (timeofday()::TIMESTAMP - start_of_step);
                
                GET DIAGNOSTICS rows_modified := ROW_COUNT;
                RAISE NOTICE 'Deleted % deduced rules', rows_modified;
                END IF;
                
                /*
                    Since the current method of generating network rules can burn through 
                    a lot of sequence numbers, there's no reason not to reclaim them once 
                    we delete inferred rules.  Once all that remains in the network ruleform
                    is original rules, we just figure out what highest allocated serial id
                    thus far is and then set the sequence accordingly.
                */
                query := 'SELECT setval(' || quote_literal(network_table || '_id_seq') || ', (SELECT max(id) FROM ' || quote_ident(network_table) ||'))';
                IF debug_flag THEN
                    RAISE NOTICE 'Query = %', query;
                ELSE
                    EXECUTE query;
                END IF;
                
                /* 
                We'll analyze the table, since we are potentially dramatically changing
                the distribution of data.  This will ensure that the query optimizer will
                have the most up-to-date information possible for future queries on the table
                */
                query := 'ANALYZE ' || quote_ident(network_table);
                IF NOT debug_flag THEN  
                start_of_step := timeofday()::TIMESTAMP;
                EXECUTE query;
                RAISE NOTICE 'End analysis; elapsed time: %', (timeofday()::TIMESTAMP - start_of_step);
                END IF;
                RETURN rows_modified;
            END;
            $BODY$
              LANGUAGE plpgsql VOLATILE
              COST 100;
            ALTER FUNCTION ruleform.np_clear_deduced_rules(character varying)
              OWNER TO core;
            COMMENT ON FUNCTION ruleform.np_clear_deduced_rules(character varying) IS 'Removes deduced rules from the specified network ruleform, leaving only original rules.';
            ]]>
        </sql>
        <rollback> DROP FUNCTION ruleform.location_name(bigint); </rollback>
    </changeSet>
</databaseChangeLog>
