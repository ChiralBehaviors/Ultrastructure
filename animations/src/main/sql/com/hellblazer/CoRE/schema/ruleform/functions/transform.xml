<?xml version="1.0" encoding="UTF-8"?>

<databaseChangeLog xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
    http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-2.0.xsd">
    
    <changeSet id="1" author="hhildebrand">
        <sql splitStatements="false"><![CDATA[
            CREATE OR REPLACE FUNCTION ruleform.transform(p_event_name character varying, p_resource_name character varying, p_product_name character varying)
              RETURNS character varying AS
            $BODY$
            DECLARE
                _event_id ruleform.product.id%TYPE;
             
                _resource_id ruleform.resource.id%TYPE;
                _product_id ruleform.product.id%TYPE;
                
                _metarules_cursor CURSOR (e ruleform.product.id%TYPE) FOR SELECT * FROM transformation_metarule WHERE service = e ORDER BY sequence_number;
                _metarule ruleform.transformation_metarule%ROWTYPE;
                
                _protocol_cursor CURSOR (e ruleform.product.id%TYPE, b ruleform.product.id%TYPE, r ruleform.resource.id%TYPE) FOR SELECT * FROM transformation WHERE service = e AND product = b AND resource = r ORDER BY sequence_number;
                _protocol ruleform.transformation%ROWTYPE;
                
                _SAME_ CONSTANT ruleform.relationship.id%TYPE NOT NULL := relationship_id('(SAME)');
                _ORIGINAL_RESOURCE_ CONSTANT ruleform.resource.id%TYPE NOT NULL := resource_id('(ORIGINAL)');
                _ORIGINAL_ENTITY_ CONSTANT ruleform.product.id%TYPE NOT NULL := product_id('(ORIGINAL)');
                 
                _mapped_resource_id ruleform.resource.id%TYPE;
                _mapped_product_id ruleform.product.id%TYPE;
                
                _protocol_resource_id ruleform.resource.id%TYPE;
                _protocol_product_id ruleform.product.id%TYPE;
                
                _found_product ruleform.product.id%TYPE;
                _product_attribute_rule ruleform.product_attribute%ROWTYPE;
                
                _value_type ruleform.attribute.value_type%TYPE;
                _value_as_text VARCHAR := NULL;
                
                _matched_protocol BOOLEAN NOT NULL := FALSE;
                
            BEGIN
                SELECT event_id(p_event_name) INTO STRICT _event_id;
                --SELECT event_id(p_event_2_name) INTO STRICT _event_2_id;
                SELECT resource_id(p_resource_name) INTO STRICT _resource_id;
                SELECT product_id(p_product_name) INTO STRICT _product_id;
                
                OPEN _metarules_cursor(_event_id);
                <<metarule_loop>>
                LOOP FETCH _metarules_cursor INTO _metarule;
                    IF NOT FOUND THEN
                        RAISE NOTICE 'No applicable metarules found';
                        CLOSE _metarules_cursor;
                        RETURN '';
                    END IF;
                    RAISE NOTICE 'Processing metarule %', _metarule.sequence_number;
                    
                    BEGIN
                        IF _metarule.resource_map = _SAME_ THEN
                            _mapped_resource_id := _resource_id; -- No mapping; use original
                        ELSE
                            SELECT child INTO STRICT _mapped_resource_id 
                            FROM resource_network 
                            WHERE parent = _resource_id 
                              AND relationship = _metarule.resource_map;
                        END IF;
                        EXCEPTION
                            WHEN NO_DATA_FOUND THEN
                                RAISE NOTICE 'No mapped resource found for mapping ''%'' using relationship ''%'' in metarule #%', p_resource_name, relationship_name(_metarule.resource_map), _metarule.id;
                                CONTINUE;
                            WHEN TOO_MANY_ROWS THEN
                                RAISE EXCEPTION 'Mapping event ''%'' using relationship ''%'' returns more than one event in metarule #%', p_event_2_name, relationship_name(_metarule.resource_map), _metarule.id;
                    END;
                    RAISE NOTICE 'Mapped Resource is %', resource_name(_mapped_resource_id);
                    
                    BEGIN
                        IF _metarule.product_map = _SAME_ THEN
                            _mapped_product_id := _product_id; -- No mapping; use original
                        ELSE
                            IF _metarule.product_network_resource IS NULL THEN
                                RAISE EXCEPTION 'Transformation Metarule Rule #% is incorrect, in that it has a NULL value for product_network_resource when its product_map is set to ''(SAME)''', _metarule.id;
                            END IF;
                        
                            SELECT child INTO STRICT _mapped_product_id
                            FROM product_network 
                            WHERE parent = _product_id 
                              AND relationship = _metarule.product_map
                              AND resource = _metarule.product_network_resource;
                        END IF;
                        EXCEPTION
                            WHEN NO_DATA_FOUND THEN
                                RAISE EXCEPTION 'No mapped product found for mapping ''%'' using relationship ''%'' and resource ''%'' in metarule #%', p_product_name, relationship_name(_metarule.product_map), resource_name(_metarule.product_network_resource), _metarule.id;
                            WHEN TOO_MANY_ROWS THEN
                                RAISE EXCEPTION 'Mapping product ''%'' using relationship ''%'' and resource ''%'' returns more than one event in metarule #%', p_product_name, relationship_name(_metarule.product_map), resource_name(_metarule.product_network_resource), _metarule.id;
                    END;
                    RAISE NOTICE 'Mapped Product is %', product_name(_mapped_product_id);
                    
                    RAISE NOTICE 'Examining Protocol rules now...';
                    OPEN _protocol_cursor(_event_id, _mapped_product_id, _mapped_resource_id);
                    
                    <<protocol_loop>>
                    LOOP FETCH _protocol_cursor INTO _protocol;
                        EXIT WHEN NOT FOUND;
            
                        RAISE NOTICE 'Processing protocol rule #%', _protocol.id;
                        RAISE NOTICE 'Assign to ''%''', resource_name(_protocol.assign_to);
            
                        _matched_protocol := TRUE;
            
                        IF _protocol.resource_key = _ORIGINAL_RESOURCE_ THEN
                            _protocol_resource_id := _resource_id;
                        ELSE
                            _protocol_resource_id := _protocol.resource_key;
                        END IF;
                        RAISE NOTICE 'Resource: ''%''', resource_name(_protocol_resource_id);
            
                        IF _protocol.product_key = _ORIGINAL_ENTITY_ THEN
                            _protocol_product_id := _product_id;
                        ELSE
                            _protocol_product_id := _protocol.product_key;
                        END IF;
                        RAISE NOTICE 'Product: ''%''', product_name(_protocol_product_id);
            
                        RAISE NOTICE 'Relationship: ''%''', relationship_name(_protocol.relationship_key);
                        RAISE NOTICE 'Attribute: ''%''', attribute_name(_protocol.attribute);
                        RAISE NOTICE 'Product Attribute Resource: ''%''', resource_name(_protocol.product_attribute_resource);
            
                        SELECT child INTO _found_product
                        FROM product_network
                        WHERE parent = _protocol_product_id
                          AND relationship = _protocol.relationship_key
                          AND resource = _protocol_resource_id;
            
                        IF NOT FOUND THEN
                            RAISE NOTICE 'Didn''t find anything using these keys; on to the next rule';
                            _matched_protocol := FALSE;
                            CONTINUE;
                        END IF;
                        
                        RAISE NOTICE 'Found the Product ''%''', product_name(_found_product);
            
                        SELECT * INTO _product_attribute_rule
                        FROM product_attribute
                        WHERE resource = _protocol.product_attribute_resource
                          AND product = _found_product
                          AND attribute = _protocol.attribute;
                        
                        _value_type := get_attribute_type(_protocol.attribute);
                        IF _value_type = 'boolean' THEN
                            _value_as_text := _product_attribute_rule.boolean_value::VARCHAR;
                        ELSEIF _value_type = 'text' THEN
                            _value_as_text := _product_attribute_rule.text_value::VARCHAR;
                        ELSEIF _value_type = 'integer' THEN
                            _value_as_text :=  _product_attribute_rule.integer_value::VARCHAR;
                        ELSEIF _value_type = 'product' THEN
                            _value_as_text := product_name(_product_attribute_rule.product_value);
                        ELSEIF _value_type = 'numeric' THEN
                            _value_as_text := _product_attribute_rule.numeric_value::VARCHAR;
                        ELSE
                            RAISE EXCEPTION 'Don''t know how to find a % type of value in a product attribute rule', _value_type;
                        END IF;
                        
                        RAISE NOTICE '-------> Found ''%'' for attribute ''%''', _value_as_text, attribute_name(_protocol.attribute);
                        
                        IF _value_as_text IS NOT NULL THEN
                            EXIT protocol_loop;
                        END IF;
            
                        RAISE NOTICE 'Done with protocol rule #%', _protocol.id;
            
                    END LOOP protocol_loop;
                    CLOSE _protocol_cursor;
                    
                    IF _metarule.stop_on_match IS TRUE AND _matched_protocol THEN
                        RAISE NOTICE 'The metarule says to stop processing, so we will stop now.';
                        EXIT metarule_loop;
                    END IF;
                    
                    RAISE NOTICE 'Done with protocol rules';
                    RAISE NOTICE 'Done with Transformation Metarule #%', _metarule.id;
                    
                    
                    
                    
                    
                END LOOP metarule_loop;
                CLOSE _metarules_cursor;
                
                RETURN _value_as_text;
            END;
            $BODY$
              LANGUAGE plpgsql VOLATILE
              COST 100;
            ALTER FUNCTION ruleform.transform(character varying, character varying, character varying)
              OWNER TO core;
            ]]>
        </sql>
        <rollback> DROP FUNCTION ruleform.transform(character varying, character varying, character varying); </rollback>
    </changeSet>
</databaseChangeLog>
